\chapter{设计}
\label{chap:design}


本章我们将介绍云搜索正确性的快速验证系统的整个系统构造。首先，我们会介绍该系统的整体框架，介绍它是有那些部分组成的，每个部分是什么功能的以及各个部分之间是怎么交互的。然后，我们会介绍整个系统里面一些重要的细节，比如为了提升整体效率而设计的一些方案，比如树状的证明结构。

\section{系统的整体架构}

考虑到高可靠性，扩展性，高可维护性的要求，我们将系统分为了Search Server, Search Client, Query Node, Correctness Server, Integrity Server这几个组成部分。
Search Client:是负责发起搜索任务的模块。该模块接受用户的输入，然后把该搜索关键词发送到Search Server进行查询。在服务端返回结果后，Search Client可以对该结果以及随结果返回的证明进行验证，以此来判断该结果是否正确。
Search Server: 如其名所言，是负责接收搜索任务的模块。该模块接收从Search Client发送过来的搜索请求，对该搜索请求进行一些初步处理，比如去除一些无关词语，然后会把本次搜索的关键词发送到各个Query Node。每一个Query Node会返回他们拥有的和本次搜索结构相关的索引内容。在各个Query Node返回它们的查询结果后，Search Server会对这些结果进行整合，这样就得到了一个完整的搜索结果。然后，Search Server会把这个结果分别发送到Correctness Server和Integrity Server去进行证明的计算。等到证明计算完成，Search Server就把搜索结果和证明一起返回给客户端。到这里，本次搜索的过程就结束了。
Query Node: Query Node负责一部分的索引查询。在我们的系统中，索引被按照尺寸大小分成了M份。如果我们有N个Query Node, 我们用0，1，2…N-1进行编号。编号为i的Query Node负责编号为i, i+N, i+2*N,…的索引文件。当一个查询到来的时候，Query Node查询自己负责的那部分索引里面是否有本次搜索包含的关键词部分，如果有就返回相应的内容，如果没有就告知没有。
Correctness Server: 计算正确性证明。Correctness Server使用了稍后会介绍的树状证明结构。该结构能够将正确性计算从一次非常耗时的计算分解成多个可以快速计算的小任务，以此来充分利用计算机集群以及多个CPU核来加快计算的速度。
Integrity Server: 计算完整性证明。该计算与正确性证明是同时进行的，来加快整个证明的计算速度。
在我们的系统中，每个模块都是单独的进程。模块这件是通过HTTP协议进行通讯，所以各个模块可以随意的部署到不同的机器，这样可以充分利用整个计算机集群，以提供非常不错的可扩展性。
\myfig{framework.eps}{3.5in}{系统的整体框架 }{des:structure}

\section{树状证明}

我们取 D = \{$d_1$\, $d_2$, ..., $d_n$\}表示某个关键词的倒排索引里面的文档集合。
我们取D的子集 S = \{$d_{i_1}$, $d_{i_2}$, ..., $d_{i_m}$\}，那么公式提的方法，我们要计算S属于D的Membership Witness的话，我们将近需要对集合D里面的每一个元素进行累乘，然后进行一次乘方计算。
在我们的设计里面使用了GMP这个库进行高精度数学计算。经过测试，我们发现连续乘方的速度比先累乘的速度要快很多。于是我们就采用了连续乘方的方式。但连续乘方这样的计算方式有一个问题，那就是计算步骤是相互依赖的，于是没法使用并行计算进行加快。
文章【】提出了一种RSA树的结构用来进行高效的集合元素的存在性证明。我们在其基础上设计了树状证明这样的结构。
我们取e为大于1的整数，对于文档集合D，我们对其进行树状结构的构建。为了便于描述，我们把这样的树叫做T(e, D),它有如下的特点:
\begin{enumerate}
  \item T(e, D) 是一颗三层的树
  \item 叶子节点保存文档的质数表示。第i叶子节点保存对应文档$d_i$的质数表示。
  \item T(e, D) 有 m = $\lceil \frac{m}{e} \rceil$ 中间层节点。第i个中间层节点 $m_i$ 存储它所有子节点组成集合的Accumulator。
  \item 除了最后一个中间层节点，每个中间层节点有且仅有e个子节点。最后一个中间层节点有不多于e个的子节点。
\end{enumerate}

对于这样的结构，我们如果要证明某个叶子存在，可以先证明它属于某个中间层节点，然后再证明这个中间层节点存在，也就是证明这个中间层节点属于根节点。按照这个思路，我们取M = \{$m_0, m_1, ..., m_{m-1}$\},G($m_i$) = \{$d_j$ | $d_j$ 是 $m_i$的子节点 \}, 取D的子集S = \{$d_{i_1}$, $d_{i_2}$, ..., $d_{i_m}$\}。 那么我们对于 $S \subseteq D$ 是如下这样:
\begin{enumerate}
  \item 把S拆分成 $S_0$, $S_1$, $S_{m-1}$，其中 $S_i$ = $S \bigcap G(m_i)$。 也就是说 $S_i$ 包含S中的那些属于第i个中间层节点的元素。
  \item 对于每个非空的 $S_i$, 我们计算 $S_i \subseteq G(m_i)$的证明: $p_i = g^{\Pi_{\mu \in G(m_i) - S_i} r(\mu)} mod N$, 这里 $r(\mu)$ 是 $\mu$的质数表示。 
  \item 对于每个非空的 $S_i$, 我们计算 $m_i \in M$的证明:$q_i =  g^{\Pi_{\mu \in M, \mu \ne m_i} r(\mu)} mod N$
  \item 我们的树状证明由全部的$(S_i, p_i, q_i, m_i, a)$元组组成 , 这里的a是集合M的Accumulator.
\end{enumerate}

有了这样的树状证明，我们就可以按照以下步骤进行验证:
\begin{enumerate}
  \item 检查 $\cap S_i = S$来证明S中的每个元素都没有遗漏，都包含在了证明中。
  \item 检查 $p_i^{\Pi_{\mu \in S_i} \mu} = m_i mod N$来证明 $S_i \subseteq G(m_i)$
  \item 检查 $q_i^{m_i} = a$ 来证明 $m_i in M$
  \item 检查 a 是否和客户自己计算并保存在本地的一样，一次来保证这个树状结构不是云端随意构造的
\end{enumerate}

使用树状证明的好处是：1. 对于$S_i$是空集的情况，我们是不需要进行计算的。2. 我们在将S划分成$S_0$, $S_1$, $S_{m-1}$之后, 对$S_i$它们进行的计算是没有相互依赖关系的，我们可以使用并行计算来进行加速。

树状证明有着 O(|S|) 的空间复杂度。这个和搜索结构的空间复杂度是一致的。所以树状证明不会使得整体的空间复杂度增加，是完全可以接受的。

\myfig{tree.eps}{3.5in}{由20个文档组成， e = 4的树状结构}{des:tree}
\section{事先计算}
在证明的生成过程中，我们用到了很多计算量很大且重复使用次数很多的一些数据。对于每个文档的质数表示。。。
\section{Worker任务分配机制}
\section{基于概率的验证}
我们的系统在证明生成上的效率相比原来的方法有了不少提升。但对于那些对证明要求不高的使用场景，每次搜索的时候都要去计算证明的话，是比较浪费计算资源，也增加了用户的等待时间，是得不偿失的。

对于那样的场景，我们提出了一种基于概率的验证方式。对于搜索，我们提供两种模式，一种是非验证搜索，该种模式下服务端只需要返回搜索结果，无需进行证明的生成，另一种是验证搜索，该种模式下服务端要同时返回结果以及证明。

假设云服务商的搜索不是完全正确的，假设其错误概率为p。在一般情况下，我们使用非验证搜索这个效率更高，使用资源更少的搜索方式。比如说我们进行了n次非验证搜索。这时由于没有证明，我们是不知道云服务商给的结果是否是正确的。然后我们在这n非验证搜索里面抽取m次进行验证搜索。

为了防止云服务商对于验证搜索时给正确结构，而非验证搜索时给错误的结果，我们首先要比较验证搜索和非验证搜索的结果，如果不一致，说明云服务上的搜索是不正确的。

在验证了两种搜索结果一致后，我们再对m个验证搜索的结果进行验证。由于云服务商的错误概率是p，那么在这m个验证中，我们发现云服务商是有问题的概率是$1-(1-p)^m$

我们在表TODO中列举了一些数据结果，从这些结果来看，我们只需要不多的检测就能有很高的概率来检测出来云服务商是否是有问题的。
