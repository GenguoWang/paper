\chapter{相关工作}
\label{chap:relatedwork}
在本章，我们介绍本课题用到的一些相关的工作。主要的介绍了我们系统使用的云搜索验证机制。该机制使用了RSA Accumulator\cite{goodrich2002efficient,verifiableindex}来进行集合元素的存在性验证。接下来，我们先介绍RSA Accumulator，然后再介绍下基于RSA Accumulator的验证机制。

\section{RSA Accumulator}
在文章\cite{benaloh1994one}中，Benaloh和de Mare首次提出了One-way Accumulator的概念。One-way Accumulator主要是用来将一个集合的所有元素累积到一个比较小的值，同时该值保有一定了原集合的信息，可以用来做一些集合属性的验证。

本课题使用的验证系统是基于一种特别的One-way Accumulator：RSA Accumulator\cite{goodrich2002efficient}.
RSA Accumulator是One-way Accumulator\cite{benaloh1994one}的一种直观的扩展。它可以用来计算集合的membership witness(用于证明一个元素属于一个集合)和nonmembership witness(用于证明一个元素不属于一个集合)。在强RSA假设的保证下\cite{baric1997collision}，人们是无法在有限计算资源下伪造出这些Witness的。我们取整数k为加密强度参数，k越大加密级别越高。令 $l = \lfloor k/2 \rfloor - 2$，并令 $\chi_k$ 为集合$\mathbb{Z}_{2^l}$中的质数元素的集合，取$n = pq$为长度k的随机的模数，其中p和q是两个长度相等的安全质数。

取集合$\chi_k$的一个子集X = \{$x_1, x_2, ... , x_{|X|}$\}作为输入集合，那么集合X的每个元素就都是质数，并取g为n的一个随机的二次剩余模量。那么集合X的Accumulator为:
\begin{equation} c = g^{\prod_{i = 1}^{|X|} x_i}\ mod\ n \end{equation}

我们可以把这个Accumulator理解成类似集合的指纹。任何人在不得知p和q的情况下，是无法在多项式时间内找到另一个集合$Y \neq X$，且集合Y的Accumulator也是c。这个性质可以有强RSA假设来保证的。如果有人能做到找到这样的集合，就说明他已经突破了强RSA假设。目前来说，强RSA假设用于了众多的安全加密领域，表明它还是足够安全的。

对于集合元素$x_j$，它的Membership Witness为：
\begin{equation} \label{eq:sw} c_{x_j} = g^{\prod_{i=1, i \ne j}^{|X|} x_i}\ mod\ n \end{equation}

如果我们要验证$x_j \in X$的话，只需要验证$(c_{x_j})^{x_j} = c\ mod\ n$是否成立。

对于一个属于$\chi_k$却不属于集合X的元素x，它的Nonmember Witness为一个二元组(a,d)\cite{li2007universal},其中a和d满足：
\begin{equation} c^a = d^x\ mod\ n\end{equation}

以上说的Membership Witness和Nonmembership Witness都是针对单个元素的，如果需要一次验证多个元素，那么我就就需要计算多个Witness并进行多次验证，这显得非常效率底下。为了处理多个元素的情况，以上的方法被稍微进行一些如下扩展，使之可以用作多个元素的Membership Witness和Nonmembership Witness。

我们取X的子集$X^{\prime} = \{x_{i_1}, x_{i_2}, ... , x_{i_{|X^\prime}}\}$, 那么$X_\prime \subseteq X$的Membership Witness为:
\begin{equation} \label{eq:w} c_{X^\prime} = g^{\prod_{x \in X - X^\prime} x}\ mod\ n \end{equation}

有了这个Membership Witness, 我们如果要证明$X_\prime \subseteq X$ 只需要验证下式是否成立:
\begin{equation} \label{eq:vw} c_{X^\prime}^{\prod_{x \in X^\prime} x} = c\ mod\ n\end{equation}
从式子\ref{eq:vw}可以看出，对于$X_\prime \subseteq X$的验证，我们所需要关于集合X的信息只要知道它的Accumulator c就行了，而不用知道它包含哪些元素。

我们另去集合 $Y = \{y_1, y_2, ... , y_{|Y|}\}$，它的每个元素$y_i$都是质数，且 $Y \bigcap X = \phi$。那么集合Y相对于X的Nonmembership Witness是这样一个二元组(a, d) 其中
$au + bv = 1, d = g^{-b}\ mod\ n, u = \prod_{x \in X} x, v = \prod_{y \in Y} y$

如果我们要证明 $Y \bigcap X = \phi$，只需要验证下式是否成立：
\begin{equation} \label{eq:vnw} c_a = d^v g\ mod\ n \end{equation}

\section{集合交集的证明}
有了上一个小结介绍的Accumulator和Witness, 我们在这里介绍一种方法，可以用他们来生成集合交集是否正确的证明以及相应的验证方法。比如说有个用户要求计算两个集合$X_1, X_2$的交集，然后云端就计算了 $X = X_1 \bigcap X_2$返回给用户，同时返回由X分别属于$X_1, X_2$的Membership Witness组成的正确性证明。由于Membership Witness是无法伪造的，用户可以通过等式\ref{eq:vw}来验证X是不是正确的结果。

但是这里还存在一个问题，就是计算X可能没有包含全部的交集元素。这个时候X也满足同时属于$X_1, X_2$，可以通过用户的验证，但却不是正确的结果。这说明仅仅用正确性证明是不够的。为了处理这种只返回部分结果的情况，我们需要一个完整性证明来保证集合X包含集合$X_1$，$X_2$的交集的全部元素。也就是说($X_1 - X$)不包含任何属于集合$X_2$的元素。这样的完整性证明有以下几个部分组成:
\begin{itemize}
\item 集合$X_\prime = X_1 - X$
\item $X_\prime$属于$X_1$的Membership Witness
\item $X_prime$不包含任何属于$X_2$的元素的Nonmembership Witness
\end{itemize}

用户可以通过等式\ref{eq:vnw}来验证Nonmembership Witness。在验证了正确性证明和完整性证明后，用户需要验证$X + X_\prime = X_1$来保证$X_prime$的正确性。这个验证可以通过计算$X + X_\prime$这个集合的Accumulator，然后与集合$X_1$的Accumulator进行比较。如果相等，则说明$X + X_\prime = X_1$成立。

上面我们讲了两个集合交集的证明，简单扩展性就可以用于多个集合。对于m个集合的交集 $X = X_1 \bigcap X_2 \bigcap ... \bigcap X_m$。正确性证明还是和两个集合的情况一样，只是变成需要m个Membership Witness。至于完整性证明的话，我们还是选$X_\prime = X_1 - X$，那么我们需要证明$X_\prime$的每个元素至少不属于$X_2, X_3,...,X_m$中的一个。也就是说，我们需要对$X_\prime$的每个元素计算一个Nonmembership Witness。考虑到每个集合含有元素的多少可能会有较大的差异，我们可以选择含有元素最少的集合代替$X_1$来计算$X_\prime$，这样得到的$X_\prime$也是含有最少的元素数目，这样我们需要的Nonmembership Witness的数目也是最少的。

\section{验证机制}
为了应用上面的Accumulator和Witness到搜索验证上，我们需要有一个把文档编号啊，Term等元素映射到质数表示的方法。幸运的是，关于质数表示的问题，文章\cite{gennaro1999secure,goodrich2002efficient}给出了一个可用的方法。该方法可以把任意k位的元素映射到3k位的质数空间上。文章\cite{verifiableindex}中提出的验证机制的主要思路是把文档搜索的过程归结到集合之间求交集的过程，然后使用上一小节描述的RSA Accumulator以及Membership Witness、Nonmembership Witness来对集合求交集的结果进行验证。

首先，作为数据拥有着，用户需要自己选择或者随机生成一组安全的质数p和q，然后选择n=pq的一个随机二次剩余模数g。其中的n和g，用户会告诉云服务商。而p和q则需要自行保密。同时，用户需要将质数表示的生成器也告诉云服务商。

这里，用户有个小的技巧，用户可以使用p和q来加速Accumulator的计算。由于p和q都是与g互质的，由欧拉定理可知$g^\phi(n)\ mod\ n = 1$。于是我们可以得到$g^x\ mod\ n  = g^{x mod \phi(n)}\ mod\ ni$。这里$\phi(n)$为欧拉函数，$\phi(n) = (p-1)(q-1)$。

整个验证机制可以分为建立可验证的索引、云端检索和证明生成、验证证明这三个步骤。
下面我们对这三个步骤分别进行介绍。
\subsection{建立可验证的索引}
为了保证索引和Accumulator的正确性，这一步骤是需要用户在本地环境操作的。为了使用RSA Accumulator来进行验证，我们使用倒排索引的方式给每个Term $t_i$建立到包含$t_i$的文档集合$D_i$。每一个文档用一个整数进行编号，记为docID。

这样我们就得到一系列文档集合$D_i$。然后我们需要对每个集合$D_i$计算它的Accumulator，并存储在本地环境，用于之后的结果验证。

在用户建立好索引并计算好Accumulator之后，便可以把文档、索引和Accumulator值之类的一起上传到云端。在后续的搜索里面，用户就无需在本地进行这些计算了，而不是没进行一次搜索，用户就要计算一次。

\subsection{云端检索和证明生成}
这一步骤的工作室云端完成的。在云服务接受到用户搜索请求时，它首先是把这个请求拆分成一个一个的Term $t_i$。然后它到索引数据里面找$t_i$对应的文档集合$D_i$。随后我们对每一个文档集合$D_i$计算交集。这个交集里包含的文档，就是这次搜索的结果。

我们以一个两个关键词的查询为例，比方说这个两个关键词为$t_i$、$t_j$,他们在倒排索引中对于的文档集合为$D_i$、$D_j$。那么搜索的结果是同时包含$t_i$、$t_j$的文档，也就是两个文档集合的交集$D = D_i \bigcap S_j$。

接下去我们计算这个结果的证明，也就是证明$D = D_i \bigcap D_j$。我们的证明又两块组成：1. 正确性证明：使用Membership Witness来证明$D \subseteq D_i$和$D \subseteq D_j$，2. 完整性证明：使用Nonmembership Witness来证明 $(D - D_i) \bigcap D_j = \phi$。

结合正确性证明和完整性证明，我就便可以证明$D = D_i \bigcap D_j$，也就证明了搜索结果是正确的了。

\subsection{验证证明}
这一步在用户本地进行。用户收到了云端返回的搜索结果和结果证明之后，使用等式\ref{eq:vw}来验证正确性证明，使用等式\ref{eq:nvw}来验证完整性证明。两个验证都通过的话，说明搜索结果是正确的。

\section{本章小结}
本章介绍了本课题相关的已有研究。主要是介绍了用于集合元素存在性验证的RSA Accumulator和基于RSA Accumulator的一套验证机制。
