\chapter{相关工作}
\label{chap:relatedwork}
在本章，我们介绍本课题用到的一些相关的工作。主要的介绍了我们系统使用的云搜索验证机制。该机制使用了RSA Accumulator\cite{goodrich2002efficient,verifiableindex}来进行集合元素的存在性验证。接下来，我们先介绍RSA Accumulator，然后再介绍下基于RSA Accumulator的验证机制。

\section{RSA Accumulator}
RSA Accumulator是One-way Accumulator\cite{benaloh1994one}的一种直观的扩展。它可以用来计算集合的membership witness(用于证明一个元素属于一个集合)和nonmembership witness(用于证明一个元素不属于一个集合)。
取X = \{$x_1, x_2, ... , x_{|X|}$\}作为输入集合，其中的每个元素$x_i$都是质数。然后我们选择两个比较大(比如说1024位的)的质数。随后我们取与n=pq互质的一个数g作为底数。那么集合X的Accumulator为:
\begin{equation} c = g^{\prod_{i = 1}^{|X|} x_i}\ mod\ n \end{equation}

我们可以把这个Accumulator理解成类似集合的指纹。任何人在不得知p和q的情况下，是无法在多项式时间内找到另一个集合$Y \neq X$，且集合Y的Accumulator也是c。这个性质可以有强RSA假设来推导出。

我们取X的子集$X^{\prime} = \{x_{i_1}, x_{i_2}, ... , x_{i_{|X^\prime}}\}$, 那么$X_\prime \subseteq X$的Membership Witness为:
\begin{equation} \label{eq:w} c_{X^\prime} = g^{\prod_{x \in X - X^\prime} x}\ mod\ n \end{equation}

有了这个Membership Witness, 我们如果要证明$X_\prime \subseteq X$ 只需要验证下式是否成立:
\begin{equation} \label{eq:vw} c_{X^\prime}^{\prod_{x \in X^\prime} x} = c\ mod\ n\end{equation}
从式子\ref{eq:vw}可以看出，对于$X_\prime \subseteq X$的验证，我们所需要关于集合X的信息只要知道它的Accumulator c就行了，而不用知道它包含哪些元素。

我们另去集合 $Y = \{y_1, y_2, ... , y_{|Y|}\}$，它的每个元素$y_i$都是质数，且 $Y \bigcap X = \phi$。那么集合Y相对于X的Nonmembership Witness是这样一个二元组(a, d) 其中
$au + bv = 1, d = g^{-b}\ mod\ n, u = \prod_{x \in X} x, v = \prod_{y \in Y} y$

如果我们要证明 $Y \bigcap X = \phi$，只需要验证下式是否成立：
\begin{equation} \label{eq:vnw} c_a = d^v g\ mod\ n \end{equation}

\section{验证机制}
我们的系统采用肋类似文章\cite{verifiableindex}中描述的验证机制。该验证机制的主要思路是把文档搜索的过程归结到集合之间求交集的过程，然后使用上一小节描述的RSA Accumulator以及Membership Witness、Nonmembership Witness来对集合求交集的结果进行验证。整个验证机制可以分为建立可验证的索引、云端检索和证明生成、验证证明这三个步骤。

下面我们对这三个步骤分别进行介绍。
\subsection{建立可验证的索引}
为了保证索引和Accumulator的正确性，这一步骤是需要用户在本地环境操作的。为了使用RSA Accumulator来进行验证，我们使用倒排索引的方式给每个Term $t_i$建立到包含$t_i$的文档集合$D_i$。每一个文档用一个整数进行编号，记为docID。

这样我们就得到一系列文档集合$D_i$。然后我们需要对每个集合$D_i$计算它的Accumulator，并存储在本地环境，用于之后的结果验证。

在用户建立好索引并计算好Accumulator之后，便可以把文档、索引和Accumulator值之类的一起上传到云端。在后续的搜索里面，用户就无需在本地进行这些计算了，而不是没进行一次搜索，用户就要计算一次。

\subsection{云端检索和证明生成}
这一步骤的工作室云端完成的。在云服务接受到用户搜索请求时，它首先是把这个请求拆分成一个一个的Term $t_i$。然后它到索引数据里面找$t_i$对应的文档集合$D_i$。随后我们对每一个文档集合$D_i$计算交集。这个交集里包含的文档，就是这次搜索的结果。

我们以一个两个关键词的查询为例，比方说这个两个关键词为$t_i$、$t_j$,他们在倒排索引中对于的文档集合为$D_i$、$D_j$。那么搜索的结果是同时包含$t_i$、$t_j$的文档，也就是两个文档集合的交集$D = D_i \bigcap S_j$。

接下去我们计算这个结果的证明，也就是证明$D = D_i \bigcap D_j$。我们的证明又两块组成：1. 正确性证明：使用Membership Witness来证明$D \subseteq D_i$和$D \subseteq D_j$，2. 完整性证明：使用Nonmembership Witness来证明 $(D - D_i) \bigcap D_j = \phi$。

结合正确性证明和完整性证明，我就便可以证明$D = D_i \bigcap D_j$，也就证明了搜索结果是正确的了。

\subsection{验证证明}
这一步在用户本地进行。用户收到了云端返回的搜索结果和结果证明之后，使用等式\ref{eq:vw}来验证正确性证明，使用等式\ref{eq:nvw}来验证完整性证明。两个验证都通过的话，说明搜索结果是正确的。
